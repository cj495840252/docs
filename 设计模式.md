# 设计模式



|      | 模式                                                         | 包括                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | **创建型模式** 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 | 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） |
| 2    | **结构型模式** 这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。 | 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） |
| 3    | **行为型模式** 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。 | 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） |

## 工厂模式

```JAVA
interface Trait{
    // 公用的抽象方法
    void fn();
}
public class Factory{
    Trait fn(Type){
        switch(Type){
                case class1 -> {return new Class1},
                case class2 -> {return new Class2},
                ....
        }
    }
}
class Class1 implements Trait{ void fn(){}}
class Class2 implements Trait{ void fn(){}}
```

## 抽象工厂模式

通过接口接受对象，类似rust的动态分派

```java
public abstract interface AbstractFactory{
    pub Factory1 getFactory1();
    pub Factory2 getFactory2();
    ....
}

public interface Factory1{
    // 公共方法
    public void fn1();
}
public interface Factory2{
    // 公共方法
    public void fn2();
}

class Class1 implements Factory1{...}
class Class2 implements Factory1{...}
...
class FactoryImpl1 implements AbstractFactory{
    // type in Class1, Class2...
    public Factory1 getFactory1(type){
        switch(type){
                Class1 -> return new Class1,
                Class2 -> return new Class2
        }
        return null
    }
    pub Factory2 getFactory2(type){
        return null
    }
    
}
    
    
class Classa implements Factory2{...}
class Classb implements Factory2{...}
...
    
class FactoryImpl2 implements AbstractFactory{
    pub Factory1 getFactory1(){
        return null
    }
    // type in Classa, Classb...
    public Factory2 getClass(type){
        switch(type){
                Classa -> return new Classa,
                Classb -> return new Classb
        }
        return null
    }
}

class AbstractFactoryImpl{
    // type in (Factory1,Factory2..)
    public AbstractFactory getFactory(type){
        switch(type){
                factory1 -> {
                    retrun new FactoryImpl1
                },
                ...
        }
        return null
    }
}
```



## 单例模式

通过私有化构造函数实现, 也可以通过枚举实现

```JAVA
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```

### 优点

- 内存中只有一个实例，减少内存开销，尤其是频繁创建和销毁实例时（如管理学院首页页面缓存）。
- 避免资源的多重占用（如写文件操作）。

### 缺点

- 没有接口，不能继承。
- 与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心实例化方式。

### 使用场景

- 生成唯一序列号。
- WEB 中的计数器，避免每次刷新都在数据库中增加计数，先缓存起来。
- 创建消耗资源过多的对象，如 I/O 与数据库连接等。

## 建造者模式


在软件系统中，一个复杂对象的创建通常由多个部分组成，这些部分的组合经常变化，但组合的算法相对稳定。
例如去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出不同的"套餐"。

### 优点

- 分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。
- 可以更好地控制构建过程，隐藏具体构建细节。
- 代码复用性高，可以在不同的构建过程中重复使用相同的建造者。

### 缺点

- 如果产品的属性较少，建造者模式可能会导致代码冗余。
- 增加了系统的类和对象数量。

### 使用场景

- 需要生成的对象具有复杂的内部结构。
- 需要生成的对象内部属性相互依赖。

## 原型模式

用一个容器缓存对象，每次需要创建的时候找到对应的对象clone一个返回。需要实现cloneable

### 优点

- 性能提高
- 避免构造函数的约束

### 缺点

- 配备克隆方法需要全面考虑类的功能，对已有类可能较难实现，特别是处理不支持串行化的间接对象或含有循环结构的引用时。
- 必须实现 `Cloneable` 接口。

### 使用场景

- 资源优化
- 类初始化需要消耗大量资源（如数据、硬件资源）
- 性能和安全要求高的场景
- 通过 `new` 创建对象需要复杂的数据准备或访问权限时
- 一个对象需要多个修改者
- 对象需提供给其他对象访问并可能被各个调用者修改时
- 通常与工厂方法模式一起使用，通过 `clone` 创建对象，然后由工厂方法提供给调用者



## 适配器模式

旨在解决不同接口之间的兼容性问题。属于结构型设计模式

### 优点

- 促进了类之间的协同工作，即使它们没有直接的关联。
- 提高了类的复用性。
- 增加了类的透明度。
- 提供了良好的灵活性。

### 缺点

- 过度使用适配器可能导致系统结构混乱，难以理解和维护。
- 在Java中，由于只能继承一个类，因此只能适配一个类，且目标类必须是抽象的。

### 使用建议

- 适配器模式应谨慎使用，特别是在详细设计阶段，它更多地用于解决现有系统的问题。
- 在考虑修改一个正常运行的系统接口时，适配器模式是一个合适的选择。

```java
// 两个接口，让第二个接口能给适配第一个接口,
// 那么就实例化第一个接口，然后通过match去选择使用
public interface MediaPlayer {
   public void play(String audioType, String fileName);
}
public interface AdvancedMediaPlayer { 
   public void playVlc(String fileName);
   public void playMp4(String fileName);
}

public class MediaAdapter implements MediaPlayer {
   AdvancedMediaPlayer advancedMusicPlayer;
 
   public MediaAdapter(String audioType){
      if(audioType.equalsIgnoreCase("vlc") ){
         advancedMusicPlayer = new VlcPlayer();       
      } else if (audioType.equalsIgnoreCase("mp4")){
         advancedMusicPlayer = new Mp4Player();
      }  
   }
 
   @Override
   public void play(String audioType, String fileName) {
      if(audioType.equalsIgnoreCase("vlc")){
         advancedMusicPlayer.playVlc(fileName);
      }else if(audioType.equalsIgnoreCase("mp4")){
         advancedMusicPlayer.playMp4(fileName);
      }
   }
}
```

## 桥接模式

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，

主要解决的问题：避免使用继承导致的类爆炸问题，提供更灵活的扩展方式。

### 优点

- **抽象与实现分离**：提高了系统的灵活性和可维护性。
- **扩展能力强**：可以独立地扩展抽象和实现。
- **实现细节透明**：用户不需要了解实现细节。

### 缺点

- **理解与设计难度**：桥接模式增加了系统的理解与设计难度。
- **聚合关联**：要求开发者在抽象层进行设计与编程。

### 使用建议

- 当系统需要在**抽象化角色和具体化角色之间增加灵活性**时，考虑使用桥接模式。
- 对于不希望使用继承或因多层次继承导致类数量急剧增加的系统，桥接模式特别适用。
- 当一个类存在两个独立变化的维度，且这两个维度都需要扩展时，使用桥接模式。

## 过滤器模式

用于将对象的筛选过程封装起来，允许使用不同的筛选标准动态地筛选对象。

### 优点

1. **封装性**：筛选逻辑被封装在独立的筛选器对象中。
2. **灵活性**：可以动态地添加、修改或组合筛选条件。
3. **可扩展性**：容易添加新的筛选标准，无需修改现有代码。

### 缺点

- **复杂性**：随着筛选条件的增加，系统可能变得复杂。
- **性能问题**：如果筛选器组合过于复杂，可能会影响性能。

### 使用建议

- 当筛选逻辑可能变化或需要根据不同标准动态筛选对象时，考虑使用过滤器模式。
- 在设计时，确保筛选器的接口和实现保持一致，以便于组合和扩展。

## 组合模式

**是用于把一组相似的对象当作一个单一的对象。**

主要解决的问题

- 简化树形结构中对象的处理，无论它们是单个对象还是组合对象。
- 解耦客户端代码与复杂元素的内部结构，使得客户端可以统一处理所有类型的节点。

### 使用场景

- 当需要表示对象的层次结构时，如文件系统或组织结构。
- 当希望客户端代码能够以一致的方式处理树形结构中的所有对象时。

### 优点

1. **简化客户端代码**：客户端可以统一处理所有类型的节点。
2. **易于扩展**：可以轻松添加新的叶子类型或树枝类型。

### 缺点

- **违反依赖倒置原则**：组件的声明是基于具体类而不是接口，这可能导致代码的灵活性降低。

### 使用建议

- 在设计时，优先使用接口而非具体类，以提高系统的灵活性和可维护性。
- 适用于需要处理复杂树形结构的场景，如文件系统、组织结构等。

## 装饰器模式

### 优点

- **低耦合**：装饰类和被装饰类可以独立变化，互不影响。
- **灵活性**：可以动态地添加或撤销功能。
- **替代继承**：提供了一种继承之外的扩展对象功能的方式。

### 缺点

- **复杂性**：多层装饰可能导致系统复杂性增加。

### 使用建议

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。属于结构型模式

我觉得类似于给这个对象创建一个上下文，执行额外的代码

- 在需要动态扩展功能时，考虑使用装饰器模式。
- 保持装饰者和具体组件的接口一致，以确保灵活性。

## 外观模式

外观模式（Facade Pattern）**隐藏系统的复杂性**，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式**涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用**。

**类似创建一个客户端，封装基本的创建和使用过程**

### 优点

1. **减少依赖**：客户端与子系统之间的依赖减少。
2. **提高灵活性**：子系统的内部变化不会影响客户端。
3. **增强安全性**：隐藏了子系统的内部实现，只暴露必要的操作。

### 缺点

- **违反开闭原则**：对子系统的修改可能需要对外观类进行相应的修改。

### 使用建议

- 在需要简化复杂系统访问时使用外观模式。
- 确保外观类提供的方法足够简单，以便于客户端使用。

## 享元模式

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式

通过**共享对象来减少创建大量相似对象时的内存消耗**。类似原型模式，用一个容器来缓存最近访问过的对象，存在则clone一个，不存在就创建一个并且缓存

### 优点

- **减少内存消耗**：通过共享对象，减少了内存中对象的数量。
- **提高效率**：减少了对象创建的时间，提高了系统效率。

### 缺点

- **增加系统复杂度**：需要分离内部状态和外部状态，增加了设计和实现的复杂性。
- **线程安全问题**：如果外部状态处理不当，可能会引起线程安全问题。

### 使用建议

- 在创建大量相似对象时考虑使用享元模式。
- 确保享元对象的内部状态是共享的，而外部状态是独立于对象的。

## 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能，这种类型的设计模式属于结构型模式。

**代理模式通过引入一个代理对象来控制对原对象的访问**

- 代理模式解决的是在直接访问某些对象时可能遇到的问题，例如对象创建成本高、需要安全控制或远程访问等。

### 优点

- **职责分离**：代理模式将访问控制与业务逻辑分离。
- **扩展性**：可以灵活地添加额外的功能或控制。
- **智能化**：可以智能地处理访问请求，如延迟加载、缓存等。

### 缺点

- **性能开销**：增加了代理层可能会影响请求的处理速度。
- **实现复杂性**：某些类型的代理模式实现起来可能较为复杂。

### 使用建议

- 根据具体需求选择合适的代理类型，如远程代理、虚拟代理、保护代理等。
- 确保代理类与真实对象接口一致，以便客户端透明地使用代理。

- **与适配器模式的区别**：适配器模式改变接口，而代理模式不改变接口。
- **与装饰器模式的区别**：装饰器模式用于增强功能，代理模式用于控制访问。

## 责任链模式

责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于**行为型模式**。

**允许将请求沿着处理者链传递，直到请求被处理为止。解耦请求发送者和接收者，使多个对象都有可能接收请求，而发送者不需要知道哪个对象会处理它。**

### 优点

1. **降低耦合度**：发送者和接收者之间解耦。
2. **简化对象**：对象不需要知道链的结构。
3. **灵活性**：通过改变链的成员或顺序，动态地新增或删除责任。
4. **易于扩展**：增加新的请求处理类很方便。

### 缺点

1. **请求未被处理**：不能保证请求一定会被链中的某个处理者接收。
2. **性能影响**：可能影响系统性能，且调试困难，可能导致循环调用。
3. **难以观察**：运行时特征不明显，可能妨碍除错。

### 使用建议

- 在处理请求时，如果有多个潜在的处理者，考虑使用责任链模式。
- 确保链中的每个处理者都明确知道如何传递请求到链的下一个环节。

```java
public abstract class ChainPattern{
    protected ChainPattern nextChainNode;
    public void setNext(ChainPattern node){
        this.nextChainNode = node
    }
    
    public abstract fn(){
        // 如果满足条件就处理，不满足就调用下一个
        if condition{
            todo!()
        }else{
            nextChainNode().fn()
        }
    }
}
```

## 命令模式

解决在软件系统中请求者和执行者之间的紧耦合问题，特别是在需要对行为进行记录、撤销/重做或事务处理等场景。

### 优点

1. **降低耦合度**：请求者和执行者之间的耦合度降低。
2. **易于扩展**：新命令可以很容易地添加到系统中。

### 缺点

- **过多命令类**：系统可能会有过多的具体命令类，增加系统的复杂度。

### 使用建议

- 在GUI中，每个按钮或菜单项可以视为一条命令。
- 在需要模拟命令行操作的场景中使用命令模式。

## 解释器模式

RUST中的macro，创建语法树实现

用于**当某一特定类型的问题频繁出现，并且可以通过一种简单的语言来表达这些问题的实例时。**

定义一种语言的文法表示，并创建一个解释器，该解释器能够解释该语言中的句子。它属于行为型模式。这种模式被用在 SQL 解析、符号处理引擎等。

## 迭代器模式

### 优点

1. **支持多种遍历方式**：不同的迭代器可以定义不同的遍历方式。
2. **简化聚合类**：聚合类不需要关心遍历逻辑。
3. **多遍历支持**：可以同时对同一个聚合对象进行多次遍历。
4. **扩展性**：增加新的聚合类和迭代器类都很方便，无需修改现有代码。

### 缺点

- **系统复杂性**：每增加一个聚合类，就需要增加一个对应的迭代器类，增加了类的数量。

### 使用建议

- 当需要访问聚合对象内容而不暴露其内部表示时，使用迭代器模式。
- 当需要为聚合对象提供多种遍历方式时，考虑使用迭代器模式。

## 中介模式

通过引入一个中介者对象来封装和协调多个对象之间的交互，从而降低对象间的耦合度。

**解决对象间复杂的一对多关联问题**，避免对象之间的高度耦合，简化系统结构。

- 当系统中多个类相互耦合，形成网状结构时。建议使用

**经典聊天室案例**

### 优点

1. **降低复杂度**：将多个对象间的一对多关系转换为一对一关系。
2. **解耦**：对象之间不再直接引用，通过中介者进行交互。
3. **符合迪米特原则**：对象只需知道中介者，不需要知道其他对象。

### 缺点

- **中介者复杂性**：中介者可能会变得庞大和复杂，难以维护。

### 使用建议

- 当系统中对象间存在复杂的引用关系时，考虑使用中介者模式。
- 通过中介者封装多个类的行为，避免生成过多的子类。

## 备忘录模式

备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象，备忘录模式属于行为型模式。

备忘录模式允许在不破坏封装性的前提下，捕获和恢复对象的内部状态。

例如：

- **游戏存档**：保存游戏进度，允许玩家加载之前的存档。
- **Windows中的Ctrl+Z**：实现撤销操作。
- **IE浏览器的后退**：允许用户回退到之前的页面。
- **数据库事务管理**：通过事务日志保存状态，实现回滚。

### 优点

- **提供状态恢复机制**：允许用户方便地回到历史状态。
- **封装状态信息**：用户不需要关心状态的保存细节。

### 缺点

- **资源消耗**：如果对象的状态复杂，保存状态可能会占用较多资源。

### 使用建议

- 在需要保存和恢复数据状态的场景中使用备忘录模式。
- 考虑使用原型模式结合备忘录模式，以节约内存。

## 观察者模式

观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。

我觉得可以用mpsc实现，比这个方便，每一对关系维护一个channel。状态改变的时候遍历channel发个消息就行

rust里面需要手动实现，`Arc<Mutex<Reader>>`

### 优点

- **抽象耦合**：观察者和主题之间是抽象耦合的。
- **触发机制**：建立了一套状态改变时的触发和通知机制。

### 缺点

- **性能问题**：如果观察者众多，通知过程可能耗时。
- **循环依赖**：可能导致循环调用和系统崩溃。
- **缺乏变化详情**：观察者不知道主题如何变化，只知道变化发生。

### 使用建议

- 在需要降低对象间耦合度，并且对象状态变化需要触发其他对象变化时使用。
- 考虑使用Java内置的观察者模式支持类，如`java.util.Observable`和`java.util.Observer`。

## 状态模式

将状态封装成class，然后定义一个context class，记录这个状态

### 优点

- **封装状态转换规则**：将状态转换逻辑封装在状态对象内部。
- **易于扩展**：增加新的状态类不会影响现有代码。
- **集中状态相关行为**：将所有与特定状态相关的行为集中到一个类中。
- **简化条件语句**：避免使用大量的条件语句来切换行为。
- **状态共享**：允许多个上下文对象共享同一个状态对象。

### 缺点

- **增加类和对象数量**：每个状态都需要一个具体的状态类。
- **实现复杂**：模式结构和实现相对复杂。
- **开闭原则支持不足**：增加新状态或修改状态行为可能需要修改现有代码。

### 使用建议

- 当对象的行为随状态改变而变化时，考虑使用状态模式。
- 状态模式适用于替代复杂的条件或分支语句。

```JAVA
public interface State {
   public void doAction(Context context);
}

public class Context {
   private State state;
   public Context(){
      state = null;
   }
   public void setState(State state){
      this.state = state;     
   }
   public State getState(){
      return state;
   }
}
```



## 空对象模式

添加一个字段，isNull表示这个对象是不是空的，类似于Rust的Option思想的None值。避免对None值得处理



## 策略模式

实现和状态模式一样，一个context记录选择得算法，然后封装每一个算法成class，context使用一个field记录选择得算法然后调用

在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

### 优点

1. **算法切换自由**：可以在运行时根据需要切换算法。
2. **避免多重条件判断**：消除了复杂的条件语句。
3. **扩展性好**：新增算法只需新增一个策略类，无需修改现有代码。

### 缺点

1. **策略类数量增多**：每增加一个算法，就需要增加一个策略类。
2. **所有策略类都需要暴露**：策略类需要对外公开，以便可以被选择和使用。

### 使用建议

- 当**系统中有多种算法或行为**，且它们之间可以相互替换时，使用策略模式。
- 当系统需要动态选择算法时，策略模式是一个合适的选择。



## 模板模式

解决在多个子类中重复实现相同的方法的问题，通过将通用方法抽象到父类中来避免代码重复。

### 优点

- **封装不变部分**：算法的不变部分被封装在父类中。
- **扩展可变部分**：子类可以扩展或修改算法的可变部分。
- **提取公共代码**：减少代码重复，便于维护。

### 缺点

- **类数目增加**：每个不同的实现都需要一个子类，可能导致系统庞大。

### 使用建议

- 当有多个子类共有的方法且逻辑相同时，考虑使用模板方法模式。
- 对于重要或复杂的方法，可以考虑作为模板方法定义在父类中。

```JAVA
public abstract class Game {
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();
 
   //模板
   public final void play(){
 
      //初始化游戏
      initialize();
 
      //开始游戏
      startPlay();
 
      //结束游戏
      endPlay();
   }
}
```

## 访问者模式

在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。

重载方法名，根据传入的形参决定调用的方法

### 优点

- **单一职责原则**：访问者模式符合单一职责原则，每个类只负责一项职责。
- **扩展性**：容易为数据结构添加新的操作。
- **灵活性**：访问者可以独立于数据结构变化。

### 缺点

- **违反迪米特原则**：元素需要向访问者公开其内部信息。
- **元素类难以变更**：元素类需要维持与访问者的兼容。
- **依赖具体类**：访问者模式依赖于具体类而不是接口，违反了依赖倒置原则。

### 使用建议

- 当对象结构稳定，但需要在其上定义多种新操作时，考虑使用访问者模式。
- 当需要避免操作"污染"对象类时，使用访问者模式封装操作。

### 注意事项

- 访问者模式可以用于功能统一，如报表生成、用户界面显示、拦截器和过滤器等。